<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AB Studio AI Chat</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
      body {
          font-family: sans-serif;
           margin: 0;
            padding: 0;
          background-color: #1a1a1a;
           color: white;
        display: flex;
         flex-direction: column;
           height: 100vh;
      }
       .chat-header {
           background-color: #222;
          color: white;
           padding: 15px;
          text-align: center;
         font-size: 1.5em;
       position: fixed;
        top: 0;
           left: 0;
            width: 100%;
          z-index: 100;
        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            display: flex;
           align-items: center;
          justify-content: space-between;
     }
     .chat-header img {
       width: 40px;
      height: 40px;
       border-radius: 50%;
       margin-right: 8px;
    }
  .menu-button {
       padding: 5px 10px;
         cursor: pointer;
       }
        .history-menu {
        position: fixed;
         top: 60px;
            right: 0;
          width: 300px;
          height: calc(100vh - 60px);
         background-color: #333;
         border-left: 1px solid #444;
          box-shadow: -2px 0 5px rgba(0, 0, 0, 0.2);
           z-index: 101;
        overflow-y: auto;
        padding: 10px;
      }
        .menu-header {
         padding: 10px;
         display: flex;
          align-items: center;
         justify-content: space-between;
         border-bottom: 1px solid #444;
    }
      .menu-header span {
          cursor: pointer;
     }
     .history-items {
          padding: 10px;
     }
    .history-item {
       border: 1px solid #444;
        padding: 10px;
         margin-bottom: 10px;
       border-radius: 4px;
           cursor: pointer;
    }
    .history-item:hover {
      background-color: #444;
     }
    .chat-container {
         flex: 1;
         display: flex;
          flex-direction: column;
          overflow: hidden;
        margin-top: 60px;
     }
     .chat-body {
        flex: 1;
         padding: 15px;
         overflow-y: auto;
          display: flex;
        flex-direction: column;
       }
        .message {
         margin-bottom: 8px;
           padding: 8px;
            border-radius: 8px;
          max-width: 70%;
             word-wrap: break-word;
              white-space: pre-line;
             display: flex;
             align-items: center;
            position: relative;
             animation: slideIn 0.3s ease-out;
      }
       .message .copy-button,
       .message .speak-button {
            position: absolute;
          top: 0px;
            right: 0px;
            padding: 5px;
           cursor: pointer;
         opacity: 0.5;
        transition: opacity 0.2s ease;
            display: none;
   }
        .message:hover .copy-button,
       .message:hover .speak-button {
        opacity: 1;
          display: block;
      }
    .message .copy-button:hover,
       .message .speak-button:hover {
           opacity: 1;
             background-color: #555;
   }
    .user-message {
       background-color: #333;
      color: white;
        align-self: flex-end;
         border-radius: 8px 0 8px 8px;
       }
    .bot-message {
       background-color: #444;
          color: white;
         align-self: flex-start;
        border-radius: 0 8px 8px 8px;
    }
        .chat-input {
           padding: 10px;
         display: flex;
          border-top: 1px solid #333;
           align-items: center;
     }
    .chat-input input {
       flex: 1;
         padding: 8px;
           border: 1px solid #555;
         border-radius: 4px;
        background-color: #333;
           color: white;
    }
    .chat-input button {
       background-color: transparent;
       border: none;
         cursor: pointer;
       display: flex;
       align-items: center;
          margin-left: 5px;
        color: white;
      }
    .chat-input button:hover {
         opacity: 0.8;
       }
      ::-webkit-scrollbar {
         width: 8px;
    }
     ::-webkit-scrollbar-thumb {
       background-color: #666;
         border-radius: 4px;
        }
       ::-webkit-scrollbar-track {
           background-color: #222;
         }
          .typing-indicator {
           display: inline-flex;
             margin-bottom: 10px;
            align-self: flex-start;
    }
    .typing-indicator span {
       width: 8px;
         height: 8px;
        border-radius: 50%;
        background-color: #888;
         margin-right: 3px;
         animation: typing 1.4s infinite;
   }
    .typing-indicator span:nth-child(2) {
      animation-delay: 0.2s;
    }
      .typing-indicator span:nth-child(3) {
          animation-delay: 0.4s;
      }
    @keyframes typing {
     0% {
          transform: translateY(0);
              opacity: 0.4;
          }
       50% {
          transform: translateY(-4px);
             opacity: 1;
         }
     100% {
       transform: translateY(0);
          opacity: 0.4;
       }
  }
  @keyframes slideIn {
       from {
           opacity: 0;
             transform: translateY(10px);
        }
       to {
         opacity: 1;
           transform: translateY(0);
        }
   }
       .message img{
         max-width: 200px;
           max-height: 150px;
           border-radius: 5px;
        }
         .chat-input .voice-button {
           background-color: transparent;
             border: none;
           cursor: pointer;
             display: flex;
           align-items: center;
            margin-right: 5px;
           color: white;
         }
      .chat-input .voice-button:hover {
       opacity: 0.8;
         }
  </style>
</head>
<body>
    <header class="chat-header">
    <img src="https://cache.tonapi.io/imgproxy/iNMnoEReCDR47JfMedDWbTI9SN0M-9qd_tigLlDiMS0/rs:fill:200:200:1/g:no/aHR0cHM6Ly9pbWcuY29sbGVjdGlmeS5hcHAvamV0dG9uX3NwbC90b3oyeDlkbmZIYUc3c3pFamh5WlJzcWZVSkREUlVwZlhoVllxNEdRLnBuZw.webp" alt="AB Studio Logo" />
    AB Studio AI
   <div class="menu-button">
        <span class="material-icons">more_vert</span>
        </div>
   </header>
   <div class="history-menu" id="history-menu" style="display:none;">
      <div class="menu-header">
       Conversation History <span class="material-icons" id="close-menu">close</span>
      </div>
      <div class="history-items" id="history-items"></div>
   </div>
 <div class="chat-container">
    <div class="chat-body" id="chat-body"></div>
   <div class="chat-input">
     <input type="text" id="user-input" placeholder="Type your message..." autocomplete="off">
     <button id="send-button">
          <span class="material-icons">send</span>
       </button>
  </div>
</div>
    <audio id="audio" style="display: none;"></audio>
   <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.2.0/firebase-app.js";
    import { getDatabase, ref, onValue } from "https://www.gstatic.com/firebasejs/11.2.0/firebase-database.js";
         const GEMINI_API_KEY = "AIzaSyDQExNMk1SXtQ4FtV-UcT2laMz2cn9UTQ4";
           const firebaseConfig = {
               apiKey: "AIzaSyBW1WPXUN8DYhT6npZQYoQ3l4J-jFSbzfg",
              authDomain: "ab-studio-marketcap.firebaseapp.com",
             databaseURL: "https://ab-studio-marketcap-default-rtdb.firebaseio.com",
               projectId: "ab-studio-marketcap",
               storageBucket: "ab-studio-marketcap.firebasestorage.app",
              messagingSenderId: "115268088088",
             appId: "1:115268088088:web:65643a047f92bfaa66ee6d"
            };
    const app = initializeApp(firebaseConfig);
       const database = getDatabase(app);
     const chatBody=document.getElementById('chat-body');
      const userInput = document.getElementById('user-input');
    const sendButton = document.getElementById('send-button');
    const historyMenu= document.getElementById('history-menu');
     const historyItems = document.getElementById('history-items');
      const menuButton= document.querySelector('.menu-button');
     const closeMenuButton = document.getElementById('close-menu');
         let typingIndicator = null;
     let allConversations = localStorage.getItem('allConversations') ? JSON.parse(localStorage.getItem('allConversations')) : [];
       let currentConversation = [];
   const audioPlayer = document.getElementById('audio');
     const audioUrls= [];
          let isPlaying = false;
           const dbRef = ref(database,'chatbotResponses');
          let chatbotResponses= {};
           onValue(dbRef,(snapshot)=>{
              chatbotResponses=snapshot.val()
         })
    loadAudioUrls();
      loadCurrentConversation();
    function loadAudioUrls() {
      for (let i = 1; i <= 100; i++) {
            audioUrls.push(`${i}.mp3`);
       }
  }
      function loadCurrentConversation() {
       chatBody.innerHTML='';
           currentConversation.forEach(msg => sendMessage(msg.text,msg.isUser,false))
         }
       function saveCurrentConversation(){
            if(currentConversation.length>0){
             const newConvId =Date.now();
              allConversations.push({ id: newConvId , messages: [...currentConversation]})
              localStorage.setItem('allConversations',JSON.stringify(allConversations));
                 currentConversation = [];
                  loadCurrentConversation();
          }
      }
        function showTypingIndicator() {
            typingIndicator = document.createElement('div');
            typingIndicator.classList.add('typing-indicator');
         typingIndicator.innerHTML = '<span></span><span></span><span></span>';
           chatBody.appendChild(typingIndicator);
           chatBody.scrollTop = chatBody.scrollHeight;
     }
     function hideTypingIndicator() {
            if (typingIndicator) {
              typingIndicator.remove();
              typingIndicator = null;
            }
       }
    function sendMessage(message, isUser,shouldSave= true){
        const messageElement = document.createElement('div');
          messageElement.classList.add('message');
        if (isUser) {
           messageElement.classList.add('user-message');
         }  else{
              messageElement.classList.add('bot-message');
        }
    if (message.startsWith("https://") || message.startsWith("http://") &&
         (message.endsWith(".jpg") ||
          message.endsWith(".png") ||
           message.endsWith(".jpeg") ||
            message.endsWith(".gif"))
            ) {
               messageElement.innerHTML= `
                 <img src="${message}"/>
                 <span class="material-icons copy-button">content_copy</span>
                 <span class="material-icons speak-button">volume_up</span>
           `;
          }    else {
             messageElement.innerHTML= `
                  <span>${message}</span>
                 <span class="material-icons copy-button">content_copy</span>
               <span class="material-icons speak-button">volume_up</span>
            `;
      }
     const copyButton=messageElement.querySelector('.copy-button') ;
         copyButton.addEventListener('click', ()=> copyMessage(message));
     const speakButton = messageElement.querySelector('.speak-button') ;
      speakButton.addEventListener('click', () => speakMessage(message));
       chatBody.appendChild(messageElement)
      chatBody.scrollTop=chatBody.scrollHeight;
     if (shouldSave) {
        currentConversation.push({
             text: message,
            isUser: isUser
            });
       }
       }
     function copyMessage(text){
        navigator.clipboard.writeText(text)
              .then(()=>console.log("Text copied : " +text ))
             .catch(error => console.error("copy problem is : ", error));
      }
       function speakMessage(text) {
        const utterance = new SpeechSynthesisUtterance(text);
           speechSynthesis.speak(utterance)
      }
   async function getGeminiResponse(message){
      try {
        const response= await fetch(
               `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${GEMINI_API_KEY}`,
                 {
                    method:"POST",
                     headers: {
                        "Content-Type":"application/json",
                  },
                    body: JSON.stringify({
                       contents: [{
                         parts: [{
                              text:message
                         }]
                       }]
                  })
                 }
               )
              const data= await response.json();
              if (data.candidates && data.candidates[0].content && data.candidates[0].content.parts) {
                   return data.candidates[0].content.parts[0].text;
              }
               return "I'm sorry, I don't understand that.";
         }    catch(error){
                console.error("Gemini : fetch api fails or some problem - details = ", error);
           return "I'm having trouble getting a response right now.";
          }
      }
     async function getBotResponse(message){
          const lowercaseMessage = message.toLowerCase().trim();
          if (chatbotResponses && chatbotResponses[lowercaseMessage]) {
                 return chatbotResponses[lowercaseMessage];
          }  else {
             return await getGeminiResponse(message)
           }
     }
        sendButton.addEventListener('click',async ()=>{
            const message = userInput.value.trim();
          if (message) {
              if (message === '/play'){
                 playRandomSong();
                   sendMessage("Playing Music",false)
             }   else if (message === '/stop') {
                    stopMusic()
                   sendMessage('Stopped music' , false );
            }  else {
                   sendMessage(message, true) ;
                      userInput.value= '' ;
                 showTypingIndicator() ;
                   const botResponse= await getBotResponse(message) ;
                  hideTypingIndicator();
                    setTimeout(() => {
                     sendMessage(botResponse ,false) ;
                 }, 500) ;
          }
      }
     });
    userInput.addEventListener('keydown',(event)=>{
            if(event.key === 'Enter'){
            sendButton.click()
            event.preventDefault();
            }
        }) ;
       menuButton.addEventListener('click', ()=>{
             historyMenu.style.display = historyMenu.style.display ==='block' ? 'none' : 'block'
           displayConversationHistory();
         });
     closeMenuButton.addEventListener('click',()=>{
            historyMenu.style.display = 'none'
        });
     function displayConversationHistory(){
         historyItems.innerHTML = "";
            allConversations.forEach((conversation, index) =>{
                const itemDiv= document.createElement('div') ;
             itemDiv.classList.add('history-item');
                 itemDiv.innerHTML= `Conversation ${index+1}`;
                itemDiv.addEventListener('click',() => loadSpecificConversation(conversation.id)) ;
            historyItems.appendChild(itemDiv)
          });
     }
        function loadSpecificConversation(conversationId){
         chatBody.innerHTML = '';
         const selectedConversation=allConversations.find(conv => conv.id===conversationId) ;
             if (selectedConversation) {
               currentConversation = [...selectedConversation.messages];
                 loadCurrentConversation();
             }
              historyMenu.style.display= 'none' ;
        }
    function playRandomSong() {
      if (!isPlaying) {
           const randomIndex = Math.floor(Math.random() * audioUrls.length);
            const audioUrl = audioUrls[randomIndex];
              audioPlayer.src=audioUrl;
            audioPlayer.play()
             .catch(error=> { // local file error log capture from player object using  try, catch block where applicable for audio
             sendMessage("Audio Load problem, verify if it was a path / file, that were expected or contact us,  see browser for debug messages " + error , false) ;
             console.error("Audio Loading Problem using HTML media source  element api + javascript with source: " + audioUrl +  ' , message is as follow:' , error) ;
                  return
                })
           isPlaying =true;
                audioPlayer.loop=true;
           }   else {
                console.log('A current media event already running !! if you expect a new source path for your message. Then make a new `play` event, using commands ` /play or /stop ` , for your use case by typing directly');
           }
    }
     function stopMusic() {
      if(isPlaying) {
             audioPlayer.pause();
               audioPlayer.currentTime = 0;
              isPlaying= false;
          } else {
                console.log('nothing was set as audio type path for HTML to play')
            }
        }
         window.addEventListener('beforeunload',saveCurrentConversation)
       let recognition=null;
        let recordingState=false
          if('webkitSpeechRecognition' in window) {
             recognition = new webkitSpeechRecognition();
            recognition.continuous = true;
         recognition.lang= 'en-US';
         recognition.onstart = () => {
            recordingState= true
             userInput.value=""; // to clear input to type or add to it using voice input during session to avoid potential mix
           sendMessage("recording...",false) // just UI text for users
         };
           recognition.onend= ()=>{
           if(recordingState) {
             recordingState=false;
               sendButton.click() // auto trigger from javascript side on speech event by holding / or tap send buttons
           }
      }
     recognition.onresult=(event)=>{
      let interimTranscript =""; // local variable
        for(let i = event.resultIndex; i < event.results.length; i++) {
             interimTranscript+= event.results[i][0].transcript + "";// this concatenates each chunk from event , as a total message
         }
           userInput.value = interimTranscript.trim();
       };
      recognition.onerror =(event) =>{
            sendMessage("Unable to  proceed to load a source for voice by microphone interface! Check browser permission" ,false)  ; // if system related settings fail then the ui messaging of that system would provide feedback and  debug logs. if something failed in web APIs with errors during mic permission check etc.
         recordingState=false
          console.log( "A system setup problems detected please re check if browser is giving errors due to browser internal setting from the event and not any codes problem "  +  event ); // this also indicates more debug points to allow other programmer for such edge condition in a particular operation of a feature related voice API on web platforms.
         };
    }
        sendButton.addEventListener('mousedown',()=> { // long press for message records, by web events that was specifically for these specific UI elements type of interactions.
            if(recognition) {
              if(!recordingState) {
                   userInput.value = ""  ;// state handling clear existing value with fresh user request
                     recognition.start(); // trigger the api
             } else {
               recordingState = false
                recognition.stop();  // cancel all action events based if specific states does not work during the intended operations .
             }
           }else{
              sendMessage('Browser is not supported or speech recognation permission  are  missing in user settings' , false ) ; // error in system implementation where API call and system access permissions for speech  failed to invoke, or was rejected on local environment setting in  browsers ( for this local code), other systems where not implemented.  Also if browser type not correctly setup this provide a text user interface support while still providing detail if problem comes from that specific condition.
         }
     });
   </script>
</body>
</html>